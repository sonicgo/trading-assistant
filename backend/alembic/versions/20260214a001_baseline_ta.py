"""baseline schema ta

Revision ID: 20260214a001
Revises: 
Create Date: 2026-02-14T00:00:00Z

This baseline migration applies:
- schema_v2.sql (core tables, constraints, indexes)
- retention.sql (purge helper functions)

UUIDv7 IDs are expected to be generated by the application layer.
All timestamps are TIMESTAMPTZ in UTC.
"""

from alembic import op

# revision identifiers, used by Alembic.
revision = "20260214a001"
down_revision = None
branch_labels = None
depends_on = None


SCHEMA_SQL = r"""
-- Trading Assistant (ta) — schema.sql
-- Target DB: PostgreSQL
-- Notes:
-- - All IDs are UUID. UUIDv7 should be generated by the application (FastAPI/worker).
-- - All timestamps are TIMESTAMPTZ in UTC.
-- - Stream tables are append-only by convention in V1 (harden later with permissions/triggers).

BEGIN;

CREATE SCHEMA IF NOT EXISTS ta;

-- -----------------------------
-- 1) Users / tenancy
-- -----------------------------
CREATE TABLE IF NOT EXISTS ta.users (
  user_id              uuid PRIMARY KEY,
  email                text NOT NULL,
  password_hash        text NOT NULL,
  is_enabled           boolean NOT NULL DEFAULT true,
  is_bootstrap_admin   boolean NOT NULL DEFAULT false,
  created_at           timestamptz NOT NULL DEFAULT now(),
  last_login_at        timestamptz NULL,
  CONSTRAINT ck_users_email_nonempty CHECK (length(trim(email)) > 3)
);

-- case-insensitive uniqueness without citext extension
CREATE UNIQUE INDEX IF NOT EXISTS ux_users_email_lower ON ta.users (lower(email));

CREATE TABLE IF NOT EXISTS ta.portfolios (
  portfolio_id     uuid PRIMARY KEY,
  owner_user_id    uuid NOT NULL REFERENCES ta.users(user_id) ON DELETE RESTRICT,
  name             text NOT NULL,
  broker           text NOT NULL,
  base_currency    char(3) NOT NULL DEFAULT 'GBP',
  tax_treatment    text NOT NULL, -- SIPP / ISA / GIA (CHECK below)
  created_at       timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT ck_portfolios_tax_treatment CHECK (tax_treatment IN ('SIPP','ISA','GIA')),
  CONSTRAINT ck_portfolios_base_currency CHECK (base_currency ~ '^[A-Z]{3}$')
);

CREATE TABLE IF NOT EXISTS ta.portfolio_memberships (
  portfolio_id   uuid NOT NULL REFERENCES ta.portfolios(portfolio_id) ON DELETE CASCADE,
  user_id        uuid NOT NULL REFERENCES ta.users(user_id) ON DELETE CASCADE,
  created_at     timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (portfolio_id, user_id)
);

-- -----------------------------
-- 2) Registry: instruments + listings
-- -----------------------------
CREATE TABLE IF NOT EXISTS ta.instruments (
  instrument_id     uuid PRIMARY KEY,
  isin              char(12) NOT NULL,
  instrument_type   text NOT NULL, -- ETF / STOCK / ETC / FUND ...
  name              text NULL,
  created_at        timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT ck_instruments_isin_format CHECK (isin ~ '^[A-Z]{2}[A-Z0-9]{9}[0-9]$')
);

CREATE UNIQUE INDEX IF NOT EXISTS ux_instruments_isin ON ta.instruments (isin);

CREATE TABLE IF NOT EXISTS ta.instrument_listings (
  listing_id        uuid PRIMARY KEY,
  instrument_id     uuid NOT NULL REFERENCES ta.instruments(instrument_id) ON DELETE RESTRICT,
  ticker            text NOT NULL,
  exchange          text NOT NULL,      -- e.g., LSE or MIC
  trading_currency  char(3) NOT NULL,   -- GBP / USD / EUR ...
  quote_scale       text NOT NULL,      -- GBP / GBX / ...
  provider_symbol   text NULL,          -- optional symbol used by data provider
  is_primary        boolean NOT NULL DEFAULT false,
  created_at        timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT ck_listings_currency CHECK (trading_currency ~ '^[A-Z]{3}$'),
  CONSTRAINT ck_listings_quote_scale CHECK (quote_scale IN ('GBP','GBX','USD','EUR','OTHER'))
);

CREATE UNIQUE INDEX IF NOT EXISTS ux_listings_unique
  ON ta.instrument_listings (instrument_id, exchange, ticker, trading_currency, quote_scale);

CREATE INDEX IF NOT EXISTS idx_listings_instrument_id ON ta.instrument_listings (instrument_id);
CREATE INDEX IF NOT EXISTS idx_listings_exchange_ticker ON ta.instrument_listings (exchange, ticker);

-- -----------------------------
-- 3) Strategy: sleeves + versions + archives + targets
-- -----------------------------
CREATE TABLE IF NOT EXISTS ta.sleeves (
  sleeve_code    text PRIMARY KEY, -- CORE, SEMIS, ENERGY...
  name           text NOT NULL,
  description    text NULL
);

CREATE TABLE IF NOT EXISTS ta.policy_archives (
  policy_sha256  char(64) PRIMARY KEY,
  policy_json    jsonb NOT NULL,
  created_at     timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT ck_policy_sha CHECK (policy_sha256 ~ '^[0-9a-f]{64}$')
);

CREATE TABLE IF NOT EXISTS ta.manifesto_archives (
  manifesto_sha256  char(64) PRIMARY KEY,
  manifesto_md      text NOT NULL,
  created_at        timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT ck_manifesto_sha CHECK (manifesto_sha256 ~ '^[0-9a-f]{64}$')
);

CREATE TABLE IF NOT EXISTS ta.strategy_versions (
  strategy_version_id   uuid PRIMARY KEY,
  version_label         text NOT NULL,
  status                text NOT NULL, -- DRAFT / APPROVED / RETIRED
  policy_sha256         char(64) NOT NULL REFERENCES ta.policy_archives(policy_sha256) ON DELETE RESTRICT,
  manifesto_sha256      char(64) NOT NULL REFERENCES ta.manifesto_archives(manifesto_sha256) ON DELETE RESTRICT,
  created_by_user_id    uuid NOT NULL REFERENCES ta.users(user_id) ON DELETE RESTRICT,
  created_at            timestamptz NOT NULL DEFAULT now(),
  approved_at           timestamptz NULL,
  CONSTRAINT ck_strategy_status CHECK (status IN ('DRAFT','APPROVED','RETIRED'))
);

CREATE INDEX IF NOT EXISTS idx_strategy_versions_status_created
  ON ta.strategy_versions (status, created_at DESC);

CREATE TABLE IF NOT EXISTS ta.sleeve_targets (
  strategy_version_id  uuid NOT NULL REFERENCES ta.strategy_versions(strategy_version_id) ON DELETE CASCADE,
  sleeve_code          text NOT NULL REFERENCES ta.sleeves(sleeve_code) ON DELETE RESTRICT,
  target_weight        numeric(6,5) NOT NULL,
  PRIMARY KEY (strategy_version_id, sleeve_code),
  CONSTRAINT ck_target_weight CHECK (target_weight >= 0 AND target_weight <= 1)
);

-- -----------------------------
-- 4) Portfolio constituents (mapping listing -> sleeve per portfolio)
-- -----------------------------
CREATE TABLE IF NOT EXISTS ta.portfolio_constituents (
  portfolio_id      uuid NOT NULL REFERENCES ta.portfolios(portfolio_id) ON DELETE CASCADE,
  listing_id        uuid NOT NULL REFERENCES ta.instrument_listings(listing_id) ON DELETE RESTRICT,
  sleeve_code       text NOT NULL REFERENCES ta.sleeves(sleeve_code) ON DELETE RESTRICT,
  is_monitored      boolean NOT NULL DEFAULT true,
  include_in_calcs  boolean NOT NULL DEFAULT true,
  created_at        timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (portfolio_id, listing_id)
);

CREATE INDEX IF NOT EXISTS idx_constituents_portfolio ON ta.portfolio_constituents (portfolio_id);
CREATE INDEX IF NOT EXISTS idx_constituents_listing ON ta.portfolio_constituents (listing_id);

-- -----------------------------
-- 5) Market data (prices / fx / corporate actions)
-- -----------------------------
CREATE TABLE IF NOT EXISTS ta.market_data_sources (
  source_id   uuid PRIMARY KEY,
  name        text NOT NULL,
  notes       text NULL
);

CREATE TABLE IF NOT EXISTS ta.price_points (
  price_point_id        uuid PRIMARY KEY,
  listing_id            uuid NOT NULL REFERENCES ta.instrument_listings(listing_id) ON DELETE RESTRICT,
  as_of                 timestamptz NOT NULL,
  source_id             uuid NOT NULL REFERENCES ta.market_data_sources(source_id) ON DELETE RESTRICT,
  is_close              boolean NOT NULL DEFAULT false,
  raw_price             numeric(18,8) NOT NULL,
  raw_currency          char(3) NOT NULL,
  raw_quote_scale       text NOT NULL,
  normalized_price_base numeric(18,8) NULL, -- optional; fill if you normalize into GBP
  quality_flags         jsonb NOT NULL DEFAULT '{}'::jsonb,
  CONSTRAINT ck_price_currency CHECK (raw_currency ~ '^[A-Z]{3}$'),
  CONSTRAINT ck_price_quote_scale CHECK (raw_quote_scale IN ('GBP','GBX','USD','EUR','OTHER'))
);

CREATE UNIQUE INDEX IF NOT EXISTS ux_price_points_unique
  ON ta.price_points (listing_id, as_of, source_id, is_close);

-- Latest price lookup
CREATE INDEX IF NOT EXISTS idx_price_points_listing_asof_desc
  ON ta.price_points (listing_id, as_of DESC);

-- Faster "latest close" lookup
CREATE INDEX IF NOT EXISTS idx_price_points_close_latest
  ON ta.price_points (listing_id, as_of DESC)
  WHERE is_close = true;

-- Optional JSONB indexing (add only if you query/filter on quality_flags at scale)
-- CREATE INDEX IF NOT EXISTS price_points_quality_gin
--   ON ta.price_points USING gin (quality_flags);



CREATE TABLE IF NOT EXISTS ta.fx_rates (
  fx_rate_id     uuid PRIMARY KEY,
  base_currency  char(3) NOT NULL,
  quote_currency char(3) NOT NULL,
  as_of          timestamptz NOT NULL,
  rate           numeric(18,8) NOT NULL,
  source_id      uuid NOT NULL REFERENCES ta.market_data_sources(source_id) ON DELETE RESTRICT,
  CONSTRAINT ck_fx_currency_base CHECK (base_currency ~ '^[A-Z]{3}$'),
  CONSTRAINT ck_fx_currency_quote CHECK (quote_currency ~ '^[A-Z]{3}$'),
  CONSTRAINT ck_fx_rate_positive CHECK (rate > 0)
);

CREATE UNIQUE INDEX IF NOT EXISTS ux_fx_rates_unique
  ON ta.fx_rates (base_currency, quote_currency, as_of, source_id);

CREATE INDEX IF NOT EXISTS idx_fx_rates_pair_asof_desc
  ON ta.fx_rates (base_currency, quote_currency, as_of DESC);

CREATE TABLE IF NOT EXISTS ta.corporate_actions (
  corp_action_id     uuid PRIMARY KEY,
  instrument_id      uuid NOT NULL REFERENCES ta.instruments(instrument_id) ON DELETE RESTRICT,
  action_type        text NOT NULL, -- SPLIT / MERGE / ISIN_CHANGE
  effective_date     date NOT NULL,
  ratio_num          integer NULL,
  ratio_den          integer NULL,
  new_instrument_id  uuid NULL REFERENCES ta.instruments(instrument_id) ON DELETE RESTRICT,
  notes              text NULL,
  CONSTRAINT ck_corp_action_type CHECK (action_type IN ('SPLIT','MERGE','ISIN_CHANGE')),
  CONSTRAINT ck_corp_action_ratio CHECK (
    (action_type IN ('SPLIT','MERGE') AND ratio_num IS NOT NULL AND ratio_den IS NOT NULL AND ratio_num > 0 AND ratio_den > 0)
    OR (action_type = 'ISIN_CHANGE')
  )
);

CREATE INDEX IF NOT EXISTS idx_corporate_actions_instrument_date
  ON ta.corporate_actions (instrument_id, effective_date DESC);

-- -----------------------------
-- 6) Book of Record: ledger + snapshots
-- -----------------------------
CREATE TABLE IF NOT EXISTS ta.ledger_batches (
  ledger_batch_id     uuid PRIMARY KEY,
  portfolio_id        uuid NOT NULL REFERENCES ta.portfolios(portfolio_id) ON DELETE RESTRICT,
  label               text NOT NULL,
  batch_type          text NOT NULL, -- MONTHLY_CONTRIB / WAVE_A / MANUAL_FIX ...
  created_by_user_id  uuid NOT NULL REFERENCES ta.users(user_id) ON DELETE RESTRICT,
  created_at          timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_ledger_batches_portfolio_created
  ON ta.ledger_batches (portfolio_id, created_at DESC);

CREATE TABLE IF NOT EXISTS ta.ledger_entries (
  ledger_entry_id     uuid PRIMARY KEY,
  ledger_batch_id     uuid NOT NULL REFERENCES ta.ledger_batches(ledger_batch_id) ON DELETE RESTRICT,
  portfolio_id        uuid NOT NULL REFERENCES ta.portfolios(portfolio_id) ON DELETE RESTRICT,
  entry_time          timestamptz NOT NULL,
  entry_type          text NOT NULL, -- BUY / SELL / CONTRIBUTION / WITHDRAWAL / FEE / INTEREST / TRANSFER
  listing_id          uuid NULL REFERENCES ta.instrument_listings(listing_id) ON DELETE RESTRICT,
  units               numeric(24,10) NULL,
  price               numeric(18,8) NULL,
  fees_base           numeric(18,6) NOT NULL DEFAULT 0,
  cash_amount_base    numeric(18,6) NOT NULL DEFAULT 0, -- signed; + adds cash, - consumes cash
  original_currency   char(3) NULL,
  original_amount     numeric(18,6) NULL,
  notes               text NULL,
  external_ref        text NULL,
  CONSTRAINT ck_entry_type CHECK (entry_type IN ('BUY','SELL','CONTRIBUTION','WITHDRAWAL','FEE','INTEREST','TRANSFER')),
  CONSTRAINT ck_entry_units_price CHECK (
    (entry_type IN ('BUY','SELL') AND listing_id IS NOT NULL AND units IS NOT NULL AND price IS NOT NULL)
    OR (entry_type NOT IN ('BUY','SELL'))
  ),
  CONSTRAINT ck_entry_original_currency CHECK (original_currency IS NULL OR original_currency ~ '^[A-Z]{3}$')
);

CREATE INDEX IF NOT EXISTS idx_ledger_entries_portfolio_time
  ON ta.ledger_entries (portfolio_id, entry_time DESC);

CREATE INDEX IF NOT EXISTS idx_ledger_entries_portfolio_listing_time
  ON ta.ledger_entries (portfolio_id, listing_id, entry_time DESC);

CREATE TABLE IF NOT EXISTS ta.holding_snapshots (
  portfolio_id    uuid NOT NULL REFERENCES ta.portfolios(portfolio_id) ON DELETE CASCADE,
  listing_id      uuid NOT NULL REFERENCES ta.instrument_listings(listing_id) ON DELETE RESTRICT,
  units           numeric(24,10) NOT NULL DEFAULT 0,
  avg_cost_base   numeric(18,8) NULL,
  updated_at      timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (portfolio_id, listing_id)
);

CREATE TABLE IF NOT EXISTS ta.cash_snapshots (
  portfolio_id   uuid PRIMARY KEY REFERENCES ta.portfolios(portfolio_id) ON DELETE CASCADE,
  currency       char(3) NOT NULL DEFAULT 'GBP',
  cash_balance   numeric(18,6) NOT NULL DEFAULT 0,
  updated_at     timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT ck_cash_currency CHECK (currency ~ '^[A-Z]{3}$')
);

-- Optional cache (later): keep or ignore in V1.
CREATE TABLE IF NOT EXISTS ta.portfolio_summaries (
  portfolio_id        uuid PRIMARY KEY REFERENCES ta.portfolios(portfolio_id) ON DELETE CASCADE,
  as_of               timestamptz NOT NULL,
  total_value_base    numeric(18,6) NOT NULL,
  weights_by_sleeve   jsonb NOT NULL DEFAULT '{}'::jsonb,
  drift_by_sleeve     jsonb NOT NULL DEFAULT '{}'::jsonb,
  updated_at          timestamptz NOT NULL DEFAULT now()
);

-- -----------------------------
-- 7) Operations: tasks + runs + input snapshots
-- -----------------------------
CREATE TABLE IF NOT EXISTS ta.task_definitions (
  task_id          uuid PRIMARY KEY,
  scope            text NOT NULL, -- GLOBAL / PORTFOLIO
  portfolio_id     uuid NULL REFERENCES ta.portfolios(portfolio_id) ON DELETE CASCADE,
  name             text NOT NULL,
  schedule_type    text NOT NULL, -- CRON / RRULE
  schedule_expr    text NOT NULL,
  task_kind        text NOT NULL, -- PRICE_REFRESH / WEEKLY_REVIEW / MONTHLY_ALLOC / QUARTERLY_REBAL / ALERT_ONLY
  module_config    jsonb NOT NULL DEFAULT '{}'::jsonb,
  is_enabled       boolean NOT NULL DEFAULT true,
  created_by_user_id uuid NOT NULL REFERENCES ta.users(user_id) ON DELETE RESTRICT,
  created_at       timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT ck_task_scope CHECK (scope IN ('GLOBAL','PORTFOLIO')),
  CONSTRAINT ck_task_schedule_type CHECK (schedule_type IN ('CRON','RRULE'))
);

CREATE INDEX IF NOT EXISTS idx_task_definitions_enabled
  ON ta.task_definitions (is_enabled, created_at DESC);

CREATE TABLE IF NOT EXISTS ta.task_runs (
  run_id              uuid PRIMARY KEY,
  task_id             uuid NOT NULL REFERENCES ta.task_definitions(task_id) ON DELETE RESTRICT,
  portfolio_id         uuid NOT NULL REFERENCES ta.portfolios(portfolio_id) ON DELETE RESTRICT,
  strategy_version_id  uuid NOT NULL REFERENCES ta.strategy_versions(strategy_version_id) ON DELETE RESTRICT,
  started_at           timestamptz NOT NULL,
  ended_at             timestamptz NULL,
  status               text NOT NULL, -- SUCCESS / FAILED / SKIPPED / FROZEN
  input_hash           char(64) NOT NULL,
  output_summary       jsonb NOT NULL DEFAULT '{}'::jsonb,
  CONSTRAINT ck_run_status CHECK (status IN ('SUCCESS','FAILED','SKIPPED','FROZEN')),
  CONSTRAINT ck_input_hash CHECK (input_hash ~ '^[0-9a-f]{64}$')
);

CREATE INDEX IF NOT EXISTS idx_task_runs_portfolio_started
  ON ta.task_runs (portfolio_id, started_at DESC);

CREATE INDEX IF NOT EXISTS idx_task_runs_task_started
  ON ta.task_runs (task_id, started_at DESC);

CREATE TABLE IF NOT EXISTS ta.run_input_snapshots (
  run_id         uuid PRIMARY KEY REFERENCES ta.task_runs(run_id) ON DELETE CASCADE,
  snapshot_json  jsonb NOT NULL
);

-- -----------------------------
-- 8) Recommendations + LLM review
-- -----------------------------
CREATE TABLE IF NOT EXISTS ta.recommendations (
  recommendation_id  uuid PRIMARY KEY,
  run_id             uuid NOT NULL REFERENCES ta.task_runs(run_id) ON DELETE RESTRICT,
  portfolio_id       uuid NOT NULL REFERENCES ta.portfolios(portfolio_id) ON DELETE RESTRICT,
  created_at         timestamptz NOT NULL DEFAULT now(),
  status             text NOT NULL, -- DRAFT / REVIEWED / EXECUTED / IGNORED
  headline           text NOT NULL,
  rationale          jsonb NOT NULL DEFAULT '{}'::jsonb,
  constraints_report jsonb NOT NULL DEFAULT '{}'::jsonb,
  CONSTRAINT ck_reco_status CHECK (status IN ('DRAFT','REVIEWED','EXECUTED','IGNORED'))
);

CREATE UNIQUE INDEX IF NOT EXISTS ux_recommendations_run
  ON ta.recommendations (run_id);

CREATE INDEX IF NOT EXISTS idx_recommendations_portfolio_created
  ON ta.recommendations (portfolio_id, created_at DESC);

-- Optional JSONB indexing (add only if you filter/search inside rationale at scale)
-- CREATE INDEX IF NOT EXISTS recommendations_rationale_gin
--   ON ta.recommendations USING gin (rationale);



CREATE TABLE IF NOT EXISTS ta.recommendation_lines (
  line_id                 uuid PRIMARY KEY,
  recommendation_id       uuid NOT NULL REFERENCES ta.recommendations(recommendation_id) ON DELETE CASCADE,
  listing_id              uuid NOT NULL REFERENCES ta.instrument_listings(listing_id) ON DELETE RESTRICT,
  action                  text NOT NULL, -- BUY / SELL
  amount_base             numeric(18,6) NOT NULL,
  estimated_units         numeric(24,10) NULL,
  suppressed_by_min_trade boolean NOT NULL DEFAULT false,
  reason_code             text NULL,
  CONSTRAINT ck_reco_line_action CHECK (action IN ('BUY','SELL'))
);

CREATE INDEX IF NOT EXISTS idx_reco_lines_reco
  ON ta.recommendation_lines (recommendation_id);

CREATE TABLE IF NOT EXISTS ta.llm_verdicts (
  llm_verdict_id     uuid PRIMARY KEY,
  recommendation_id  uuid NULL REFERENCES ta.recommendations(recommendation_id) ON DELETE SET NULL,
  strategy_version_id uuid NULL REFERENCES ta.strategy_versions(strategy_version_id) ON DELETE SET NULL,
  provider_name      text NOT NULL,
  model_name         text NOT NULL,
  verdict            text NOT NULL, -- PASS / WARN / FAIL
  request_hash       char(64) NOT NULL,
  response_json      jsonb NOT NULL,
  created_at         timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT ck_llm_verdict CHECK (verdict IN ('PASS','WARN','FAIL')),
  CONSTRAINT ck_llm_req_hash CHECK (request_hash ~ '^[0-9a-f]{64}$')
);

CREATE INDEX IF NOT EXISTS idx_llm_verdicts_reco_created
  ON ta.llm_verdicts (recommendation_id, created_at DESC);

-- -----------------------------
-- 9) Governance: freeze, alerts, notifications, audit
-- -----------------------------
CREATE TABLE IF NOT EXISTS ta.freeze_states (
  portfolio_id      uuid PRIMARY KEY REFERENCES ta.portfolios(portfolio_id) ON DELETE CASCADE,
  is_frozen         boolean NOT NULL DEFAULT false,
  reason_code       text NULL,
  reason_detail     text NULL,
  set_by_user_id    uuid NULL REFERENCES ta.users(user_id) ON DELETE SET NULL,
  set_at            timestamptz NULL,
  cleared_by_user_id uuid NULL REFERENCES ta.users(user_id) ON DELETE SET NULL,
  cleared_at        timestamptz NULL
);

CREATE TABLE IF NOT EXISTS ta.alerts (
  alert_id      uuid PRIMARY KEY,
  portfolio_id  uuid NOT NULL REFERENCES ta.portfolios(portfolio_id) ON DELETE CASCADE,
  run_id        uuid NULL REFERENCES ta.task_runs(run_id) ON DELETE SET NULL,
  severity      text NOT NULL, -- INFO / WARN / CRITICAL
  code          text NOT NULL,
  message       text NOT NULL,
  context       jsonb NOT NULL DEFAULT '{}'::jsonb,
  created_at    timestamptz NOT NULL DEFAULT now(),
  resolved_at   timestamptz NULL,
  CONSTRAINT ck_alert_severity CHECK (severity IN ('INFO','WARN','CRITICAL'))
);

CREATE INDEX IF NOT EXISTS idx_alerts_portfolio_created
  ON ta.alerts (portfolio_id, created_at DESC);

CREATE INDEX IF NOT EXISTS idx_alerts_run
  ON ta.alerts (run_id);

CREATE TABLE IF NOT EXISTS ta.notifications (
  notification_id uuid PRIMARY KEY,
  user_id         uuid NOT NULL REFERENCES ta.users(user_id) ON DELETE CASCADE,
  portfolio_id    uuid NULL REFERENCES ta.portfolios(portfolio_id) ON DELETE SET NULL,
  channel         text NOT NULL DEFAULT 'IN_APP', -- IN_APP only in V1 (polling feed)
  payload         jsonb NOT NULL,
  status          text NOT NULL DEFAULT 'PENDING', -- PENDING / SENT / FAILED / SUPPRESSED / READ
  created_at      timestamptz NOT NULL DEFAULT now(),
  sent_at         timestamptz NULL,
  CONSTRAINT ck_notification_channel CHECK (channel IN ('IN_APP','EMAIL','TELEGRAM','SLACK','WEBPUSH')),
  CONSTRAINT ck_notification_status CHECK (status IN ('PENDING','SENT','FAILED','SUPPRESSED','READ'))
);

CREATE INDEX IF NOT EXISTS idx_notifications_user_created
  ON ta.notifications (user_id, created_at DESC);

CREATE INDEX IF NOT EXISTS idx_notifications_user_status_created
  ON ta.notifications (user_id, status, created_at DESC);

CREATE TABLE IF NOT EXISTS ta.audit_events (
  audit_event_id  uuid PRIMARY KEY,
  actor_user_id   uuid NULL REFERENCES ta.users(user_id) ON DELETE SET NULL,
  action          text NOT NULL,
  entity_type     text NOT NULL,
  entity_ref      text NOT NULL, -- flexible: uuid string, composite key, etc.
  occurred_at     timestamptz NOT NULL DEFAULT now(),
  details         jsonb NOT NULL DEFAULT '{}'::jsonb
);

CREATE INDEX IF NOT EXISTS idx_audit_events_actor_time
  ON ta.audit_events (actor_user_id, occurred_at DESC);

CREATE INDEX IF NOT EXISTS idx_audit_events_entity
  ON ta.audit_events (entity_type, entity_ref);

COMMIT;

"""

RETENTION_SQL = r"""
-- Trading Assistant (ta) — retention.sql
-- Run these from your scheduler/worker (DB is not exposed).
-- Prices are kept forever (no purge for price_points/fx_rates by default).

BEGIN;

CREATE SCHEMA IF NOT EXISTS ta;

-- Purge RunInputSnapshots older than N (default 12 months in the app scheduler).
-- NOTE: We keep task_runs forever; only the large JSON blobs get purged.
CREATE OR REPLACE FUNCTION ta.purge_run_input_snapshots(older_than interval)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_deleted bigint;
BEGIN
  WITH doomed AS (
    SELECT ris.run_id
    FROM ta.run_input_snapshots ris
    JOIN ta.task_runs tr ON tr.run_id = ris.run_id
    WHERE tr.started_at < (now() AT TIME ZONE 'utc') - older_than
  )
  DELETE FROM ta.run_input_snapshots ris
  USING doomed d
  WHERE ris.run_id = d.run_id;

  GET DIAGNOSTICS v_deleted = ROW_COUNT;
  RETURN v_deleted;
END;
$$;

-- Purge Alerts older than N.
-- If resolved_only = true, only purge alerts that have resolved_at set.
CREATE OR REPLACE FUNCTION ta.purge_alerts(older_than interval, resolved_only boolean DEFAULT true)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_deleted bigint;
BEGIN
  IF resolved_only THEN
    DELETE FROM ta.alerts
    WHERE resolved_at IS NOT NULL
      AND created_at < (now() AT TIME ZONE 'utc') - older_than;
  ELSE
    DELETE FROM ta.alerts
    WHERE created_at < (now() AT TIME ZONE 'utc') - older_than;
  END IF;

  GET DIAGNOSTICS v_deleted = ROW_COUNT;
  RETURN v_deleted;
END;
$$;

-- Purge Notifications older than N.
-- In V1 you poll, so you may want to keep a short history only.
CREATE OR REPLACE FUNCTION ta.purge_notifications(older_than interval)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_deleted bigint;
BEGIN
  DELETE FROM ta.notifications
  WHERE created_at < (now() AT TIME ZONE 'utc') - older_than;

  GET DIAGNOSTICS v_deleted = ROW_COUNT;
  RETURN v_deleted;
END;
$$;

COMMIT;

-- Example execution (run by scheduler/worker):
-- SELECT ta.purge_run_input_snapshots('12 months'::interval);
-- SELECT ta.purge_alerts('90 days'::interval, true);
-- SELECT ta.purge_notifications('90 days'::interval);

"""


def upgrade() -> None:
    # Baseline DDL
    op.execute(SCHEMA_SQL)
    # Retention helpers
    op.execute(RETENTION_SQL)


def downgrade() -> None:
    # Drop everything under schema ta. This is a baseline migration; downgrade is destructive.
    op.execute("DROP SCHEMA IF EXISTS ta CASCADE;")